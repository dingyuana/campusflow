# CampusFlow 智慧校园多智能体系统 - 教学计划

## 📋 课程信息

**课程周期**：16 天（Day 0-Day 15，共60学时，每天约4学时）
**适用对象**：计算机科学与技术、软件工程、人工智能等专业本科高年级学生及研究生（前置基础：Python程序设计、数据库原理、机器学习基础）
**核心交付**：可公网访问的"校园新生报到助手"全栈智能体应用（Hugging Face Spaces部署）

---

## 📚 教学资源目录

本课程的教学资源已整理在 `docs/` 目录下，按类别分类：

### 📁 docs/ 目录结构

```
docs/
├── README.md                      # 文档目录说明
├── 教学文件/                     # 教学相关文档和测试材料
│   ├── ragfiles/                 # RAG 测试文档（PDF、Word、Excel）
│   └── neo4j知识图谱.md         # Neo4j 知识图谱教学文档
├── 测试报告/                     # 项目测试报告
│   ├── 测试报告-Day1-Day2.md   # Day 1-2 综合测试报告
│   └── RAG测试报告-真实文档.md  # RAG 真实文档测试报告
└── 知识点补充/                    # 补充知识点和学习指南
    ├── Git-GitHub使用指南.md     # Git 和 GitHub 使用指南
    └── 环境配置指南.md             # Python 虚拟环境配置指南
```

### 📚 教学材料说明

#### 教学文件 (`docs/教学文件/`)

**RAG 测试文档** (`ragfiles/`)：
- `2025年本科新生报到手册.pdf` - 新生报到详细指南（20.53 MB）
- `东华大学学生违纪处分规定.pdf` - 学生违纪处理规定（0.57 MB）
- `东华大学2026年硕士研究生招生简章.docx` - 硕士研究生招生信息（0.02 MB）
- `院校简介.docx` - 学校基本情况介绍（0.02 MB）
- `院系设置及重点实验室.xlsx` - 院系和实验室信息（0.02 MB）

**Neo4j 知识图谱教学文档**：
- `neo4j知识图谱.md` - Neo4j 图数据库、Cypher 查询、Text-to-Cypher 教学材料

#### 测试报告 (`docs/测试报告/`)

- `测试报告-Day1-Day2.md` - Day 1-2 的综合测试报告
  - Day 1: Supabase 数据库连接测试
  - Day 2: RAG 向量库基础功能测试

- `RAG测试报告-真实文档.md` - 使用真实文档构建 RAG 的完整测试报告
  - 文档加载测试
  - 文档切分测试
  - 数据统计
  - 技术实现说明

#### 知识点补充 (`docs/知识点补充/`)

- `Git-GitHub使用指南.md` - Git 和 GitHub 的使用指南
  - Git 基础命令
  - GitHub 工作流
  - 分支管理
  - 提交规范

- `环境配置指南.md` - Python 虚拟环境配置指南
  - uv venv 使用
  - 依赖安装
  - 环境变量配置

---

#### Day 0: 项目启动与工程化初探（Docker 化部署基础）

- **理论（2h）**
  1. 多智能体系统（MAS）核心设计模式（分工协作、主从编排、动态路由）；
  2. 分布式系统中的状态管理核心问题（数据一致性、状态丢失、多端同步）；
  3. 工程化开发规范：Git Flow 工作流（主干/开发/特性/发布分支）、项目目录结构设计（前后端分离、分层架构）；
  4. Docker 容器化原理与多阶段构建（解决环境一致性）。

- **实操（6h，分步骤落地，配沙盒模板）**
  1. 项目初始化：基于模板创建仓库，配置 Python 虚拟环境/依赖（`requirements.txt`/`pyproject.toml`），设计标准项目目录（`api/`/`agents/`/`db/`/`utils/`）；
  2. Git 配置：创建 `dev`/`feature` 分支，配置 `.gitignore`，编写 Commit 规范（Conventional Commits）；
  3. 云端环境初始化：创建 Supabase 项目，关联 GitHub 仓库，配置 Supabase 云数据库（一键创建，免本地部署）；
  4. Docker 化配置：编写多阶段 `Dockerfile`，配置 `docker-compose.yml`（含 PostgreSQL/Redis/Chroma 服务栈），实现一键启动开发环境；
  5. 基础测试：编写简单的 Python 脚本，实现本地与 Supabase 的连接测试，完成第一条数据插入/查询。

- **教学要点**：
  1. **虚拟环境是必选项**：强调每个项目都必须使用虚拟环境（venv），避免依赖冲突；
  2. 重点解决学生的**环境配置问题**，提供现成的仓库模板和依赖文件；
  3. 强调项目目录结构的重要性，为后续多模块开发做铺垫；
  4. Docker 卷挂载（Volume）持久化数据，避免容器重启数据丢失。

- **课后作业**：提交 Git 仓库地址，完成 PostgreSQL 连接测试截图，推送到 `feature/day0` 分支并创建 PR；本地运行 `docker-compose up` 成功截图。

---

#### Day 1: 智能体基础与 ReAct 范式（初识 Agent）

- **理论（2h）**
  1. LLM 驱动型 Agent 的核心架构（大脑+工具+记忆）；
  2. ReAct（Reasoning + Acting）论文原理：思考 Thought → 行动 Action → 观察 Observation 循环；
  3. Tool Calling 机制：工具描述工程（Description Engineering）、参数 Schema 定义、错误重试策略；
  4. 边界情况处理：幻觉控制（防止虚构工具参数）、循环检测、拒绝回答策略。

- **实操（6h，分步骤落地）**
  1. 环境确认：检查 Docker 容器状态，配置 `.env` 文件（OpenAI API Key/Base URL）；
  2. 工具开发：在 `tools/campus_tools.py` 中定义两个基础工具（`query_campus_map`/`query_contact`），使用 `@tool` 装饰器，编写清晰的工具描述与参数注释；
  3. ReAct Agent 构建：在 `agents/campus_agent.py` 中使用 `create_react_agent` 创建基础咨询 Agent，配置系统提示词（身份+约束）；
  4. 多轮对话测试：测试单轮问答与多轮上下文保持，观察 ReAct 思考链（Thought 过程可视化）；
  5. 流式输出实现：修改 Agent 调用方式，使用 `stream` 方法实现打字机效果输出；
  6. 边界加固：添加 `recursion_limit`（最大循环10次）防止无限循环，实现工具调用异常捕获。

- **教学要点**：
  1. **工具描述决定 Agent 智商**：强调工具 `description` 的准确性直接影响 Agent 选择工具的正确率；
  2. 区分 `Tool Calling` 与 `Function Calling` 的兼容性差异；
  3. 重点观察 ReAct 循环中的"幻觉"现象（如 Agent 编造不存在的工具参数），教授纠正方法。

- **课后作业**：提交 Agent 对话截图（至少包含工具调用成功与失败案例各1个）；撰写工具描述优化实验报告（对比不同描述对路由准确率的影响）。

---

#### Day 2: 知识获取（RAG + 向量库）

- **理论（2h）**
  1. RAG 的核心流程（加载-切分-向量化-存储-检索-生成）；
  2. 混合检索策略（关键词检索+语义检索）、语义切分原则（按语义完整性、固定长度+重叠窗口）；
  3. Chroma DB 的核心特性（轻量级、嵌入式、支持本地/云端部署）、Embedding 模型的选择（开源轻量模型如 BGE-m3，适配实训）；
  4. 检索结果评估指标：召回率（Recall）、精确率（Precision）、MRR（Mean Reciprocal Rank）。

- **实操（6h，基于 LangChain 完成端到端 RAG）**
  1. 数据处理：使用 LangChain 的 `PyPDFLoader`/`UnstructuredLoader` 处理《校园报到手册》（PDF/Word），完成文本清洗、语义切分（调优 `chunk_size=500/chunk_overlap=50`）；
  2. 向量化与存储：调用开源 Embedding 模型（BGE-m3）生成向量，将文本+向量+元数据存入 Chroma（本地/云端）；
  3. 基础检索：实现语义检索（`similarity_search`）、关键词检索（`mmr`）、混合检索，对比不同检索方式的结果差异；
  4. 检索质量调优：调整切分参数（大段 vs 细粒度），观察对检索准确率的影响；
  5. 评估测试：准备 10 个测试查询，手动标注相关性，计算 Recall@3。

- **教学要点**：
  1. 重点讲解**语义切分的坑**（如切分后语义断裂，标题与正文分离），提供现成的文本处理工具类；
  2. 推荐使用**本地 Chroma** 降低学生的云端配置成本，但需说明生产环境应使用服务端 Chroma；
  3. 强调检索与生成的解耦：先验证检索质量，再接入生成模型。

- **课后作业**：完成《校园报到手册》的 RAG 系统搭建，实现任意问题的检索；提交检索结果对比截图（语义检索 vs 混合检索）；调整切分参数并提交准确率对比表格。

---

#### Day 3: 复杂关系处理（知识图谱 Neo4j）

- **理论（2h）**
  1. 图数据库核心概念（点 Node/边 Relationship/属性 Property），与关系型数据库的区别；
  2. 智慧校园场景的图建模原则（实体抽象、关系定义、属性设计）；
  3. Text-to-Cypher 原理（大模型将自然语言转为 Cypher 语句）、核心问题（语句错误、查询效率低、死循环）；
  4. 图查询优化：索引创建、关系方向设计、避免深度优先搜索爆炸。

- **实操（6h，从建模到查询的端到端实现）**
  1. Neo4j 环境部署：使用 Neo4j Aura（免费云实例）或 Docker 本地部署，完成连接配置；
  2. 图建模与数据入库：抽象校园核心实体（学生/教师/实验室/课程/院系），定义实体关系（隶属/授课/入驻/选修），编写 Cypher 脚本导入仿真数据；
  3. 基础查询：实现单跳/多跳查询（如"查询计算机学院张老师的实验室里的学生"）；
  4. Text-to-Cypher 实现：基于 LangChain 搭建 Text-to-Cypher 系统，添加语句校验（禁止 DELETE/DROP）和错误重试（3次容错），避免死循环；
  5. 跨库关联：实现 Chroma（非结构化）与 Neo4j（结构化关系）的简单混合检索（如先图查询教师，再向量检索其论文）。

- **教学要点**：
  1. 重点讲解**图建模的合理性**（避免实体冗余、关系混乱），提供智慧校园的标准图模型和 Cypher 导入脚本；
  2. 针对 Text-to-Cypher，添加**基础的语句过滤**（正则拦截危险操作）；
  3. 对比展示：同一问题的 RAG 检索 vs 图查询（如"张三的导师是谁"在图数据库中更精准）。

- **课后作业**：完成校园知识图谱的搭建，实现 3 个以上的多跳查询；提交 Neo4j Browser 可视化截图和 Text-to-Cypher 测试结果（含安全防护验证）。

---

#### Day 4: 流程编排与状态机（StateGraph 工作流）

- **理论（2h）**
  1. StateGraph 核心抽象：State（状态）、Node（节点）、Edge（边）三元组；
  2. 状态管理：TypedDict 定义、Annotated Reducers（状态合并逻辑）、Checkpoint 持久化点；
  3. 流程控制：普通边、条件边（Conditional Edges）、循环边（Retry Loop）；
  4. 可视化：Mermaid 图表生成、Graph PNG 导出，理解复杂工作流的拓扑结构。

- **实操（6h，构建报到流程状态机）**
  1. 状态定义：在 `workflows/checkin_graph.py` 中定义 `CheckInState`（含 student_id/current_step/messages/error_count）；
  2. 节点实现：编写 `verify_identity`、`check_payment`、`assign_dorm` 等业务节点函数（纯函数设计）；
  3. 条件路由：实现 `route_verify` 函数，根据验证结果路由至下一节点或人工介入（错误3次转人工）；
  4. 工作流编译：使用 `StateGraph` 构建图，添加 MemorySaver 实现断点续传；
  5. 可视化输出：生成流程图 PNG，验证流程完整性（Start → Verify → Payment → Dorm → Complete）；
  6. 异常测试：模拟中断（Ctrl+C），验证从 Checkpoint 恢复能力。

- **教学要点**：
  1. **强制要求状态不可变性**：Node 函数必须返回新 State 而非修改原对象，避免并发问题；
  2. 强调条件边的返回值必须与边映射表严格对应（类型安全）；
  3. Checkpoint 不仅是容错，更是 HITL 的基础（Day 6 会深入）。

- **课后作业**：提交 StateGraph 可视化流程图；编写测试用例覆盖正常流程与异常分支（验证失败重试3次后转人工）。

---

#### Day 5: 安全防护体系（中间件与预算控制）

- **理论（2h）**
  1. 生产级 Agent 的四层防护：预算控制（Token/Cost）、消息截断（Context Window）、敏感词过滤、PII（个人身份信息）检测；
  2. 预算控制策略：硬限制（Hard Limit）vs 软限制（Soft Limit）、Token 计费原理（BPE 编码差异）；
  3. 内容安全：敏感词 Trie 树匹配、变体识别（拼音、拆字）、正则表达式模式；
  4. 数据隐私：PII 实体识别（Presidio）、脱敏策略（Masking/Hashing）、GDPR 合规基础。

- **实操（6h，实现四层防护中间件）**
  1. 预算控制中间件：基于 `tiktoken` 实现 Token 计费，设置单次请求上限（$0.01），超限时报错或降级；
  2. 消息截断中间件：实现滑动窗口截断（保留最近5轮+系统消息）、语义摘要截断（长历史生成摘要）；
  3. 敏感词过滤：基于 DFA 算法实现敏感词检测，支持文本实时过滤与拦截提示；
  4. PII 检测集成：使用 Microsoft Presidio 检测学号/手机号/身份证，自动脱敏处理（如 138****1234）；
  5. 中间件链组装：在 StateGraph 中按序注册中间件（Budget → Truncate → Sensitive → PII）；
  6. 渗透测试：提交攻击用例（超长文本、敏感词注入、手机号泄露），验证拦截率。

- **教学要点**：
  1. **中间件顺序至关重要**：先截断再检测 PII（减少计算量），预算检查放在最前（快速失败）；
  2. PII 检测的误杀问题（如学号看起来像手机号），需调优置信度阈值；
  3. 强调成本意识：让学生查看实际 API 调用费用账单，建立经济成本概念。

- **课后作业**：提交安全防护测试报告（含 5 个攻击案例及拦截截图）；实现 PII 检测后的日志脱敏（确保日志中无敏感信息）。

---

#### Day 6: 人机协作机制（HITL 与审核工作台）

- **理论（2h）**
  1. HITL（Human-in-the-loop）设计哲学：何时介入（置信度低/高风险/异常输入）、介入方式（中断/建议/回滚）；
  2. LangGraph Interrupt 机制：抛出中断、保存快照（Snapshot）、恢复执行（Resume/Command）；
  3. 审核 UX 设计：上下文展示（Context）、决策选项（Approve/Reject/Modify）、操作审计日志；
  4. 超时策略：人工确认超时自动降级（Auto-reject/Auto-approve）、优先级队列。

- **实操（6h，构建辅导员审核工作台）**
  1. 中断点设计：在 `dorm_approval_node` 中使用 `interrupt()` 暂停流程，传递申请数据给学生；
  2. 审核控制台：实现命令行版审核界面（模拟 Web UI），展示待审核任务列表、申请详情；
  3. 决策处理：支持通过/拒绝/修改三种操作，使用 `Command(resume=...)` 恢复 Agent 执行；
  4. 并发隔离：测试多学生同时申请场景，验证 Thread ID 隔离（互不干扰）；
  5. 审计日志：记录审核人、时间、决策、理由，存储到 PostgreSQL；
  6. 超时处理：设置 5 分钟超时，超时后自动拒绝并通知学生。

- **教学要点**：
  1. **Interrupt 是状态机的一部分**：强调中断后状态被冻结，可跨进程/跨设备恢复；
  2. 区分 "人工审核" 与 "人工标注"：本课程专注审核（干预运行）；
  3. 审核界面的信息密度控制：过多上下文导致审核慢，过少导致误判。

- **课后作业**：模拟完整 HITL 流程（申请→中断→审核→恢复→完成），提交截图；编写审核超时自动处理逻辑。

---

#### Day 7: 记忆系统架构（短期与长期记忆）

- **理论（2h）**
  1. 记忆分层模型：工作记忆（短期/Thread级）、Episodic 记忆（对话历史）、Semantic 记忆（长期/User级/画像）；
2. LangGraph 存储接口：MemorySaver（Checkpointer）、Store（长期存储）、PostgresStore/RedisStore；
3. 记忆检索：向量相似度检索（相关记忆召回）、时间衰减（近期记忆加权）；
4. 记忆管理：过期清理（TTL）、重要性评分（显著性评分）、隐私合规（被遗忘权）。

- **实操（6h，构建学生画像系统）**
  1. 短期记忆实现：配置 `MemorySaver`，实现多轮对话上下文保持，测试会话隔离；
  2. 长期记忆存储：使用 `Store` 接口保存学生画像（专业/家乡/偏好），实现跨会话识别；
  3. 画像自动构建：编写 `update_student_profile` 节点，使用 LLM 从对话中提取结构化信息；
  4. 记忆检索：实现 `retrieve_relevant_memories`，基于当前查询向量检索历史相关记忆；
  5. 记忆增强生成：在 Agent 提示词中注入检索到的记忆（个性化 Greeting："欢迎回来，来自四川的同学"）；
  6. 记忆删除：实现 GDPR 合规的 "遗忘" 功能（根据 user_id 删除所有记忆）。

- **教学要点**：
  1. **区分 Checkpointer 与 Store**：前者是状态快照（临时），后者是业务数据（持久）；
  2. 记忆更新的并发控制（乐观锁），避免多会话同时修改画像导致数据丢失；
  3. 提醒学生：长期记忆可能存储敏感信息，需加密或脱敏。

- **课后作业**：测试"换设备登录"场景（新 Thread ID + 旧 User ID），验证是否能识别身份；提交学生画像自动提取的准确率测试（5条对话提取3个事实）。

---

#### Day 8: 上下文工程进阶（State/Store/Runtime 分层）

- **理论（2h）**
  1. 上下文三层架构：Invocation Config（调用级）、State（运行时状态）、Store（持久化知识）、Runtime Resources（资源句柄）；
  2. 动态配置：Configurable Fields（user_id/thread_id/模型选择/权限角色）；
  3. 依赖注入：Runtime 资源管理（DB 连接池、API Client、缓存客户端）；
  4. 多租户隔离：Namespace 策略、资源沙箱、配置工厂（Config Factory）。

- **实操（6h，实现多租户隔离）**
  1. 配置穿透：在 Node 函数中通过 `config["configurable"]` 获取 user_id/permissions；
  2. 动态工具加载：根据用户权限（admin/student）动态加载可用工具子集；
  3. 运行时资源管理：使用 `asynccontextmanager` 管理 DB 连接池生命周期；
  4. A/B 测试支持：通过 Config 动态切换模型版本（gpt-4o vs gpt-4o-mini）；
  5. 资源隔离测试：模拟两个用户同时访问，验证数据不串扰（连接池隔离）；
  6. 配置热更新：实现不停机更新配置（如调整预算限制）的高级技巧（选做）。

- **教学要点**：
  1. **Config 是函数的隐式参数**：强调所有依赖配置都应从 RunnableConfig 获取，而非全局变量；
  2. Runtime 资源的清理（`finally` 块），防止连接泄漏；
  3. 多租户下的命名空间设计（如 Store 使用 `(user_id, "profile")` 作为 key）。

- **课后作业**：实现基于角色的访问控制（RBAC）：管理员可查询所有学生，学生只能查自己；提交多租户并发测试报告。

---

#### Day 9: 系统集成协议（MCP Server 开发）

- **理论（2h）**
  1. MCP（Model Context Protocol）协议规范：Resources/Tools/Prompts 三大能力；
  2. 传输层选择：Stdio（本地进程）、SSE（Server-Sent Events）、WebSocket；
  3. LangGraph 与 MCP 桥接：`create_mcp_client`、`load_mcp_tools`、工具转换；
  4. 企业系统集成：ERP/CRM 接入 Agent 的安全策略（API Key 管理、请求签名、熔断降级）。

- **实操（6h，对接校务三大系统）**
  1. MCP Server 开发：创建 `mcp_server/campus_server.py`，封装教务/财务/宿管三个系统的查询接口；
  2. 工具定义：遵循 MCP 协议定义 `query_payment_status`、`assign_dormitory` 等工具（JSON Schema）；
  3. LangGraph 集成：使用 `ClientSession` 连接 MCP Server，加载工具到 ReAct Agent；
  4. 错误映射：将校务系统的业务错误（如"学号不存在"）转换为 Agent 可理解的友好提示；
  5. 连接池优化：维护 MCP Client 长连接，避免频繁启停进程开销；
  6. 降级测试：模拟校务 API 宕机，Cache 或 Mock 数据保持 Agent 可用。

- **教学要点**：
  1. **MCP 是进程级隔离**：强调 MCP Server 崩溃不应影响主应用，需健康检查；
  2. 敏感操作的人机确认（结合 Day 6），如缴费操作必须通过 HITL；
  3. API 限流处理（Rate Limiting），避免高并发时被封禁。

- **课后作业**：实现一个跨系统的联合查询（如"查询未缴费学生的宿舍分配情况"，需同时查财务+宿管）；提交 MCP Server 独立运行测试截图。

---

#### Day 10: CI/CD 自动化与部署（DevOps 实战）

- **理论（2h）**
  1. 持续集成/持续部署（CI/CD）核心原则：自动化测试、制品管理、蓝绿部署；
  2. GitHub Actions 工作流语法：on/push/pull_request, jobs, steps, actions/checkout；
  3. 云平台部署选项：Hugging Face Spaces（Gradio原生）、Vercel（Serverless）、Docker Hub；
  4. 监控与可观测性：Health Check、日志聚合、性能指标（Latency/Throughput）。

- **实操（6h）**
  1. 自动化测试：编写 pytest 测试用例（至少3个），覆盖 Agent 基础响应与工具调用；
  2. GitHub Actions 配置：创建 `.github/workflows/ci-cd.yml`，实现 push 时自动测试、构建 Docker 镜像；
  3. Hugging Face Spaces 部署：适配 Gradio 应用，配置 `app.py` 入口，推送至 Space；
  4. Secrets 管理：在 GitHub/HF 配置 API Key，确保不泄露到代码；
  5. 健康检查：添加 `/health` 端点，返回 DB/Agent状态；
  6. 自动化验证：提交代码后自动触发部署，访问公网 URL 验证可用性。

- **产出**：一个可公开访问的生产级智慧校园智能体应用。

---

#### Day 11: 监督者架构（Supervisor 多 Agent 协同）

- **理论（2h）**
  1. 单 Agent 瓶颈：工具过多导致选择困难、专业领域深度不足；
  2. 监督者模式（Supervisor）：主从编排（Master-Slave）、动态路由策略（基于意图/基于 Embedding）；
  3. 实现方式对比：Tool-calling（灵活） vs langgraph-supervisor（简洁）；
  4. 子 Agent 通信：状态传递标准化、结果聚合策略、错误传播机制。

- **实操（6h，构建总-分架构）**
  1. 子 Agent 封装：将已有功能封装为独立 Agent（咨询 Agent/RAG Agent/后勤 Agent）；
  2. Tool-calling 实现：Supervisor 作为中央路由，子 Agent 作为 Tool 被调用；
  3. langgraph-supervisor 重构：使用预置包简化路由配置；
  4. 路由准确率优化：添加 Few-shot 示例提升意图识别准确率至 90%+；
  5. 人工兜底：Supervisor 置信度低于阈值时，触发 HITL 转人工；
  6. 性能对比：测试 Supervisor 架构 vs 单体 Agent 的响应延迟与准确率。

- **教学要点**：
  1. **Supervisor 也是 Agent**：提示词需明确路由规则，避免循环调用（Agent A → B → A）；
  2. 子 Agent 接口标准化（输入：str，输出：str），降低集成成本；
  3. 监控路由分布（哪个子 Agent 被调用最多），优化负载。

- **课后作业**：绘制 Supervisor 架构图；提交路由准确率测试报告（20 个测试用例的混淆矩阵）。

---

#### Day 12: 并发与性能优化（并行计算）

- **理论（2h）**
  1. LangGraph 并发模型：Asyncio 事件循环、节点并行执行条件（无状态依赖）；
  2. Send API：动态任务生成（Map 阶段）、结果聚合（Reduce 阶段）；
  3. @task 装饰器：后台异步任务、并发控制（Semaphore）、结果回调；
  4. Map-Reduce 模式：任务分发 → 并行处理 → 结果归并（如批量处理新生名单）。

- **实操（6h）**
  1. 节点并行：使用 `Send` 同时查询宿舍/缴费/选课状态（3个查询并行，从7秒降至3秒）；
  2. 并发控制：限制并行节点数（如最多5个并发，防止 API 限流）；
  3. @task 异步化：将通知发送（短信/邮件）改为后台任务，不阻塞主流程；
  4. Map-Reduce 实现：批量生成 100 封欢迎信（Map 生成内容 → Reduce 合并为 PDF）；
  5. 超时与重试：部分失败处理（记录失败项，整体继续）、任务取消机制；
  6. 性能基准测试：对比串行 vs 并行版本的吞吐量（Requests/Second）。

- **教学要点**：
  1. **并行前提是无共享状态**：如果节点修改同一 State 字段，不可并行；
  2. 并发数限制的重要性（Cost Control），避免触发 API 限流或预算超支；
  3. 异步任务的持久化（Day 7 的长期记忆结合），防止任务丢失。

- **课后作业**：提交性能对比报告（响应时间、并发数、成功率）；实现批量处理任务的进度监控（显示 50/100 完成）。

---

#### Day 13: 实时信息融合（网络搜索增强）

- **理论（2h）**
  1. 搜索增强生成（SARG）vs RAG：实时性 vs 结构化；
  2. 搜索引擎集成：Tavily（高质量 AI 搜索）、DashScope（阿里云/国内内容）、DDGS（免费/DuckDuckGo）；
  3. 智能搜索决策：基于关键词（今天/明天/最新）或 LLM 判断是否需要搜索；
  4. 结果融合：去重、排序（RRF 算法）、可信度评分、引用溯源。

- **实操（6h）**
  1. 搜索工具封装：统一接口封装 Tavily/DDGS/DashScope，支持自动 failover；
  2. 搜索决策器：实现 `needs_search()` 函数，自动识别时效性问题；
  3. 混合检索实现：融合向量检索（校规）+ 搜索结果（今日天气/临时通知）；
  4. 引用标注：在回答中标注信息来源（[来源于：校园官网] / [来源于网络搜索]）；
  5. 缓存策略：搜索结果 Cache（TTL 1小时） vs 实时性要求（强制刷新）；
  6. 成本优化：搜索 API 计费监控，高频查询走 Cache。

- **教学要点**：
  1. **搜索不是万能的**：强调搜索可能返回垃圾信息，需与 RAG 结合验证；
  2. 引用标注的重要性（可解释性），避免幻觉；
  3. 搜索查询生成（Query Generation）：将"今天适合军训吗"转为"XX市今日天气"。

- **课后作业**：测试 5 个时效性问题（如"今天食堂有什么特色菜"），对比搜索结果与 RAG 结果差异；提交搜索结果可信度评分实现代码。

---

#### Day 14: 自主智能体（Deep Agents 与端到端自动化）

- **理论（2h）**
  1. Deep Agents 架构：Planning（规划）→ Tool Use（执行）→ Observation（观察）→ Reflection（反思）；
  2. 自主执行 vs 预定义工作流：灵活性 vs 可控性权衡；
  3. 安全沙箱：代码执行隔离、工具权限分级（只读 vs 读写 vs 管理员）；
  4. 反思机制：自我纠错、中间结果验证、重试策略与最大尝试限制。

- **实操（6h）**
  1. 端到端报到 Agent：输入"我要完成报到"，Agent 自动拆解为：验证→缴费→宿舍→通知；
  2. 规划能力：使用 LLM 生成执行计划（Todo List），逐步执行并检查；
  3. 反思节点：添加 `reflection_node`，检查上一步结果，错误则回溯重试（最多3次）；
  4. 安全边界：高风险操作（缴费/修改档案）自动触发 HITL 确认；
  5. 执行监控：可视化展示 Agent 执行路径（思维链 + 工具调用链）；
  6. 异常处理：单步骤失败时的补偿机制（如宿舍分配失败则保留名额，不重复扣费）。

- **教学要点**：
  1. **自主不等于放任**：必须在关键节点设置人工确认（结合 Day 6）；
  2. 规划的可解释性：让学生能看到 Agent 的"思考过程"（Plan）；
  3. 防止无限循环：严格限制重试次数与总步骤上限。

- **课后作业**：录制端到端报到流程视频（从对话到完成）；提交反思机制触发的错误纠正案例。

---

#### Day 15: 产品发布与工程交付（Gradio 应用开发）

- **理论（2h）**
  1. Gradio 架构：Blocks vs Interface、Components（Chatbot/MultimodalTextbox）、Events；
  2. 流式传输：Server-Sent Events (SSE)、异步生成器（Yield）、前端状态同步；
  3. 会话管理：Thread ID 传递、历史记录加载、多端同步；
  4. 生产优化：并发控制（Queue）、移动端适配、错误边界（Error Boundary）。

- **实操（6h）**
  1. 界面搭建：使用 `gr.ChatInterface` 构建流式聊天界面，支持上传图片（录取通知书 OCR）；
  2. 功能集成：集成前 14 天所有功能（Supervisor+RAG+Search+Memory+HITL）；
  3. 状态可视化：添加侧边栏显示"报到进度条"、"学生档案"、"当前审核状态"；
  4. 多模态支持：实现图片上传 → OCR 提取 → 自动填充表单；
  5. 部署配置：适配 Hugging Face Spaces（Dockerfile、requirements.txt、README）；
  6. 最终测试：端到端测试（注册→咨询→办理→人工审核→完成），修复最后 Bug。

- **教学要点**：
  1. **UX 是产品的面子**：强调流式输出的"感知性能"，即使后端慢，前端也要动；
  2. 错误处理：Agent 崩溃时前端显示友好提示（非技术错误码）；
  3. 性能监控：在界面上显示响应时间、Token 消耗（教育用户成本意识）。

- **课后作业**：提交最终项目仓库（含完整文档）；部署公开可访问的 Demo 链接；准备 5 分钟项目路演 PPT（技术亮点+业务价值）。

---

## 附录：教学资源清单

| 资源类型 | 具体内容 | 用途 |
|---------|---------|------|
| **代码模板** | Day 0 Starter Code（含 Dockerfile/docker-compose） | 降低环境配置门槛 |
| **数据集** | 《校园报到手册》PDF、仿真学生数据（CSV/JSON） | RAG 与图数据库导入 |
| **云资源** | Supabase 项目模板、Neo4j Aura 实例申请指南 | 免运维数据库 |
| **测试集** | 20 个咨询查询（含边界案例）、攻击用例（敏感词/PII） | 功能与安全防护测试 |
| **文档模板** | API 文档规范、架构设计文档模板、测试报告模板 | 工程化交付标准 |

---

**编制说明**：本教学计划配套《智慧校园多智能体系统开发实战》教学大纲，按 **2.5 小时理论 + 1.5 小时实操** 的节奏设计（每天4学时），共16天（Day 0-Day 15）60学时，每天形成一个可运行的增量版本，最终交付**生产级开源项目**。建议采用 Git 分支管理（`feature/day{n}` → `dev` → `main`），每天强制 Code Review 确保代码质量。

**版本日期**：2026-01-31